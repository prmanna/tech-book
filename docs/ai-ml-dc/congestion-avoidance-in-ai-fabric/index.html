<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Congestion Avoidance in AI Fabric - Part I: Explicit Congestion Notification (ECN)
  #

As explained in the preceding chapter, “Egress Interface Congestions,” both the Rail switch links to GPU servers and the inter-switch links can become congested during gradient synchronization. It is essential to implement congestion control mechanisms specifically designed for RDMA workloads in AI fabric back-end networks because congestion slows down the learning process and even a single packet loss may restart the whole training process."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://prasenjitmanna.com/tech-book/docs/ai-ml-dc/congestion-avoidance-in-ai-fabric/"><meta property="og:site_name" content="Technical Book"><meta property="og:title" content="Congestion Avoidance in AI Fabric"><meta property="og:description" content=" Congestion Avoidance in AI Fabric - Part I: Explicit Congestion Notification (ECN) # As explained in the preceding chapter, “Egress Interface Congestions,” both the Rail switch links to GPU servers and the inter-switch links can become congested during gradient synchronization. It is essential to implement congestion control mechanisms specifically designed for RDMA workloads in AI fabric back-end networks because congestion slows down the learning process and even a single packet loss may restart the whole training process."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-04-28T21:46:49+05:30"><title>Congestion Avoidance in AI Fabric | Technical Book</title>
<link rel=manifest href=/tech-book/manifest.json><link rel=icon href=/tech-book/favicon.png><link rel=canonical href=https://prasenjitmanna.com/tech-book/docs/ai-ml-dc/congestion-avoidance-in-ai-fabric/><link rel=stylesheet href=/tech-book/book.min.a61cdb2979f3c2bece54ef69131fba427dd57d55c232d3bb5fdb62ac41aa8354.css integrity="sha256-phzbKXnzwr7OVO9pEx+6Qn3VfVXCMtO7X9tirEGqg1Q=" crossorigin=anonymous><script defer src=/tech-book/fuse.min.js></script><script defer src=/tech-book/en.search.min.c669dc76aedae54b8a6a3c5a4cf704c3954c35467fac8df8efedb1e5921e24e0.js integrity="sha256-xmncdq7a5UuKajxaTPcEw5VMNUZ/rI347+2x5ZIeJOA=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/tech-book/><img src=/tech-book/logo.png alt=Logo><span>Technical Book</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-99f552133860bc21797a47fe73e93434 class=toggle>
<label for=section-99f552133860bc21797a47fe73e93434 class="flex justify-between"><a href=/tech-book/docs/5g/>5G</a></label><ul><li><input type=checkbox id=section-dfc790b73acb0410a0114547cbf5af32 class=toggle>
<label for=section-dfc790b73acb0410a0114547cbf5af32 class="flex justify-between"><a href=/tech-book/docs/5g/5g-intro/>An Overview of 5G Networking</a></label></li></ul></li><li><input type=checkbox id=section-7c4a3b16aeeb5b7194b232c1eef2f4fb class=toggle>
<label for=section-7c4a3b16aeeb5b7194b232c1eef2f4fb class="flex justify-between"><a href=/tech-book/docs/algorithms/>Algorithms</a></label><ul><li><input type=checkbox id=section-8956d82fbe6869140758f7e8679174bc class=toggle>
<label for=section-8956d82fbe6869140758f7e8679174bc class="flex justify-between"><a href=/tech-book/docs/algorithms/breadth-first-search/>Breadth First Search</a></label></li><li><input type=checkbox id=section-5a049cfad1740f3fd30565524385fa57 class=toggle>
<label for=section-5a049cfad1740f3fd30565524385fa57 class="flex justify-between"><a href=/tech-book/docs/algorithms/depth-first-search/>Depth First Search</a></label></li><li><input type=checkbox id=section-ebc049f26d82165be8c6f1f9e504e799 class=toggle>
<label for=section-ebc049f26d82165be8c6f1f9e504e799 class="flex justify-between"><a href=/tech-book/docs/algorithms/easy/>Easy Complexity</a></label></li><li><input type=checkbox id=section-1071946392bd1f431993e950147fa054 class=toggle>
<label for=section-1071946392bd1f431993e950147fa054 class="flex justify-between"><a href=/tech-book/docs/algorithms/priority-queue-and-heap/>Priority Queue and Heap</a></label></li><li><input type=checkbox id=section-08afbeb294c43ca4908c1c89a4be9d0a class=toggle>
<label for=section-08afbeb294c43ca4908c1c89a4be9d0a class="flex justify-between"><a href=/tech-book/docs/algorithms/two-pointers/>Two Pointers & Sliding Window</a></label></li><li><input type=checkbox id=section-ef36c7c4f7e0dec6525068c3c409100c class=toggle>
<label for=section-ef36c7c4f7e0dec6525068c3c409100c class="flex justify-between"><a href=/tech-book/docs/algorithms/medium/>Medium Complexity</a></label></li></ul></li><li><input type=checkbox id=section-8c7c5c4a8382299873178820b1d91be1 class=toggle checked>
<label for=section-8c7c5c4a8382299873178820b1d91be1 class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/>Data Center Networking for AI Clusters</a></label><ul><li><input type=checkbox id=section-cd3a69c68b09887f63fced84e24740c3 class=toggle>
<label for=section-cd3a69c68b09887f63fced84e24740c3 class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/ai-ml-networking/>AI/ML Networking</a></label></li><li><input type=checkbox id=section-c871539cd743741d564065cf3350789b class=toggle>
<label for=section-c871539cd743741d564065cf3350789b class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/challenges-in-ai-fabric/>Challenges in AI Fabric Design</a></label></li><li><input type=checkbox id=section-ae2230803144a95c810e910cf79943af class=toggle checked>
<label for=section-ae2230803144a95c810e910cf79943af class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/congestion-avoidance-in-ai-fabric/ class=active>Congestion Avoidance in AI Fabric</a></label></li><li><input type=checkbox id=section-c9ac637119f4d95354967fbbf641c24c class=toggle>
<label for=section-c9ac637119f4d95354967fbbf641c24c class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/ai-deep-learning-basics/>Deep Learning Basics | Artificial Neuron</a></label></li></ul></li><li><input type=checkbox id=section-3272b2d28b2b247027bf478619ca416f class=toggle>
<label for=section-3272b2d28b2b247027bf478619ca416f class="flex justify-between"><a href=/tech-book/docs/data-center/>Data Center Tips</a></label><ul><li><input type=checkbox id=section-984f932c7aba4f0a1841e8413165c947 class=toggle>
<label for=section-984f932c7aba4f0a1841e8413165c947 class="flex justify-between"><a href=/tech-book/docs/data-center/data-center-ethernet/>Data Center Ethernet</a></label></li><li><input type=checkbox id=section-bc5ac88940153a700e63e3be886c63cc class=toggle>
<label for=section-bc5ac88940153a700e63e3be886c63cc class="flex justify-between"><a href=/tech-book/docs/data-center/data-center-technologies/>Data Center Technologies</a></label></li><li><input type=checkbox id=section-86fde1ddf43700ef8191e11c59a82cf1 class=toggle>
<label for=section-86fde1ddf43700ef8191e11c59a82cf1 class="flex justify-between"><a href=/tech-book/docs/data-center/data-center-network-virtualization/>Network Virtualization in Cloud Data Centers</a></label></li></ul></li><li><input type=checkbox id=section-ddf784688e0c6d5abb681d2c57851559 class=toggle>
<label for=section-ddf784688e0c6d5abb681d2c57851559 class="flex justify-between"><a href=/tech-book/docs/manageability/>Manageability</a></label><ul><li><input type=checkbox id=section-33ac730897af6feca81c1fdb7869c57e class=toggle>
<label for=section-33ac730897af6feca81c1fdb7869c57e class="flex justify-between"><a href=/tech-book/docs/manageability/why-grpc-on-http2/>gRPC on HTTP/2</a></label></li></ul></li><li><input type=checkbox id=section-c14ae944424668ef125e10cd791a3d3d class=toggle>
<label for=section-c14ae944424668ef125e10cd791a3d3d class="flex justify-between"><a href=/tech-book/docs/networking-tips/>Networking Tips</a></label><ul><li><input type=checkbox id=section-78fdf21c03c55935d3146441b06faf3e class=toggle>
<label for=section-78fdf21c03c55935d3146441b06faf3e class="flex justify-between"><a href=/tech-book/docs/networking-tips/dns/>DNS Overview</a></label></li><li><input type=checkbox id=section-bbcb027a658dc7a2333d59078ee507f9 class=toggle>
<label for=section-bbcb027a658dc7a2333d59078ee507f9 class="flex justify-between"><a href=/tech-book/docs/networking-tips/ecmp/>ECMP Load Balancing</a></label></li><li><input type=checkbox id=section-3b39b86f18b3451e5b8a1b81c369549c class=toggle>
<label for=section-3b39b86f18b3451e5b8a1b81c369549c class="flex justify-between"><a href=/tech-book/docs/networking-tips/ip-fragmentation/>IP Fragmentation - IPv4 & IPv6</a></label></li><li><input type=checkbox id=section-c6d06c54cc91b0bc3f948d33b437fa8b class=toggle>
<label for=section-c6d06c54cc91b0bc3f948d33b437fa8b class="flex justify-between"><a href=/tech-book/docs/networking-tips/ip-tos-dscp/>IP Precedence And TOS | DSCP</a></label></li><li><input type=checkbox id=section-5f3260c76dd37177e3f89057bfe520ae class=toggle>
<label for=section-5f3260c76dd37177e3f89057bfe520ae class="flex justify-between"><a href=/tech-book/docs/networking-tips/traceroute/>Linux traceroute tool</a></label></li><li><input type=checkbox id=section-a26cc3fafb36cbc55527adf39ec83849 class=toggle>
<label for=section-a26cc3fafb36cbc55527adf39ec83849 class="flex justify-between"><a href=/tech-book/docs/networking-tips/mlag/>Multi Chassis Link Aggregation Basics</a></label></li><li><input type=checkbox id=section-36409a0abcb2d4d4baf2e0b682d1a5dd class=toggle>
<label for=section-36409a0abcb2d4d4baf2e0b682d1a5dd class="flex justify-between"><a href=/tech-book/docs/networking-tips/qos/>QoS</a></label></li><li><input type=checkbox id=section-db41e3547d316b01acf9a0ce9c04ef34 class=toggle>
<label for=section-db41e3547d316b01acf9a0ce9c04ef34 class="flex justify-between"><a href=/tech-book/docs/networking-tips/spine-leaf-arch/>Spine-leaf Architecture Basics</a></label></li><li><input type=checkbox id=section-0eb0d409074a76b8cb02624655e2434d class=toggle>
<label for=section-0eb0d409074a76b8cb02624655e2434d class="flex justify-between"><a href=/tech-book/docs/networking-tips/tcp-congestion/>TCP Congestion Control</a></label></li><li><input type=checkbox id=section-3d1710947b3c5be1a1cc33d88fcc6f54 class=toggle>
<label for=section-3d1710947b3c5be1a1cc33d88fcc6f54 class="flex justify-between"><a href=/tech-book/docs/networking-tips/tcp-data-transfer/>TCP Data Transfer</a></label></li></ul></li><li><input type=checkbox id=section-f0a392f2f083f28a4991336773716a63 class=toggle>
<label for=section-f0a392f2f083f28a4991336773716a63 class="flex justify-between"><a href=/tech-book/docs/optical-knowledge/>Optical Knowledge</a></label><ul><li><input type=checkbox id=section-18261b95a92d4fa86116243edca4e9fb class=toggle>
<label for=section-18261b95a92d4fa86116243edca4e9fb class="flex justify-between"><a href=/tech-book/docs/optical-knowledge/optical-breakout/>Optical Transceiver(Grey) & Breakout Model</a></label></li></ul></li><li><input type=checkbox id=section-a55840d746138b3d1fedb81acbccdded class=toggle>
<label for=section-a55840d746138b3d1fedb81acbccdded class="flex justify-between"><a href=/tech-book/docs/programming-tips/>Programming Tips</a></label><ul><li><input type=checkbox id=section-f929f1fe13cb5d6cc96ca3e98f9d9777 class=toggle>
<label for=section-f929f1fe13cb5d6cc96ca3e98f9d9777 class="flex justify-between"><a href=/tech-book/docs/programming-tips/c++/>C++ Tips</a></label></li></ul></li><li><input type=checkbox id=section-b35dbf5ebcd4c19926cf5a9aab6c7655 class=toggle>
<label for=section-b35dbf5ebcd4c19926cf5a9aab6c7655 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/>SystemDesign-Tips</a></label><ul><li><input type=checkbox id=section-4a618bc3b0b30107f0cec6d3bd6c025f class=toggle>
<label for=section-4a618bc3b0b30107f0cec6d3bd6c025f class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/code-deployment-system/>Design A Code-Deployment System</a></label></li><li><input type=checkbox id=section-e600754306aa95ce9c5a72b5efec6d7a class=toggle>
<label for=section-e600754306aa95ce9c5a72b5efec6d7a class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/stock-broker/>Design A Stock-Broker System</a></label></li><li><input type=checkbox id=section-bfa7a29878f65cfbb179e491c1211fa8 class=toggle>
<label for=section-bfa7a29878f65cfbb179e491c1211fa8 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/design-amazon/>Design Amazon</a></label></li><li><input type=checkbox id=section-5456837e25872f6352d861a9b5662cb1 class=toggle>
<label for=section-5456837e25872f6352d861a9b5662cb1 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/design-slack/>Design Slack</a></label></li><li><input type=checkbox id=section-5a78d16f54536a400b654f17f917bce1 class=toggle>
<label for=section-5a78d16f54536a400b654f17f917bce1 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/google-drive/>Google Drive - Design</a></label></li></ul></li></ul><ul><li><a href=/tech-book/posts/>Blog</a></li><li><a href=https://prasenjitmanna.com/ target=_blank rel=noopener>Prasenjit's Blog</a></li><li><a href=https://prasenjitmanna.com/tech-book/ target=_blank rel=noopener>Prasenjit - Tech Book</a></li><li><a href=https://prasenjitmanna.com/upskills/ target=_blank rel=noopener>Prasenjit - Upskills</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/tech-book/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Congestion Avoidance in AI Fabric</strong>
<label for=toc-control><img src=/tech-book/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#congestion-avoidance-in-ai-fabric---part-i-explicit-congestion-notification-ecn>Congestion Avoidance in AI Fabric - Part I: Explicit Congestion Notification (ECN)</a><ul><li><a href=#gpu-to-gpu-rdma-write-without-congestion>GPU-to-GPU RDMA Write Without Congestion</a></li><li><a href=#explicit-congestion-notification--ecn>Explicit Congestion Notification -ECN</a></li></ul></li><li><a href=#congestion-avoidance-in-ai-fabric---part-ii-priority-flow-control-pfc>Congestion Avoidance in AI Fabric - Part II: Priority Flow Control (PFC)</a><ul><li><a href=#dscp-based-pfc-process-over-a-layer-3-routed-interface-example-scenario>DSCP-Based PFC Process over a Layer 3 Routed Interface (Example Scenario)</a></li><li><a href=#lldp-with-dcbx>LLDP with DCBX</a></li></ul></li><li><a href=#congestion-avoidance-in-ai-fabric---part-iii-data-center-quantized-congestion-notification-dcqcn>Congestion Avoidance in AI Fabric - Part III: Data Center Quantized Congestion Notification (DCQCN)</a><ul><li><a href=#how-dcqcn-combines-ecn-and-pfc>How DCQCN Combines ECN and PFC</a></li><li><a href=#why-ecn-must-precede-xoff>Why ECN Must Precede xOFF</a></li><li><a href=#what-happens-if-xoff-is-reached-before-ecn-marking>What Happens If xOFF Is Reached Before ECN Marking?</a></li><li><a href=#dcqcn-configuration>DCQCN Configuration</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=congestion-avoidance-in-ai-fabric---part-i-explicit-congestion-notification-ecn>Congestion Avoidance in AI Fabric - Part I: Explicit Congestion Notification (ECN)
<a class=anchor href=#congestion-avoidance-in-ai-fabric---part-i-explicit-congestion-notification-ecn>#</a></h2><p>As explained in the preceding chapter, “Egress Interface Congestions,” both the Rail switch links to GPU servers and the inter-switch links can become congested during gradient synchronization. It is essential to implement congestion control mechanisms specifically designed for RDMA workloads in AI fabric back-end networks because congestion slows down the learning process and even a single packet loss may restart the whole training process.</p><p>This section begins by introducing Explicit Congestion Notification (ECN) and Priority-based Flow Control (PFC), two foundational technologies used in modern lossless Ethernet networks. ECN allows switches to mark packets, rather than dropping them, when congestion is detected, enabling endpoints to react proactively. PFC, on the other hand, offers per-priority flow control, which can pause selected traffic classes while allowing others to continue flowing.</p><p>Finally, we describe how Datacenter Quantized Congestion Notification (DCQCN) combines ECN and PFC to deliver a scalable and lossless transport mechanism for RoCEv2 traffic in AI clusters.</p><h3 id=gpu-to-gpu-rdma-write-without-congestion>GPU-to-GPU RDMA Write Without Congestion
<a class=anchor href=#gpu-to-gpu-rdma-write-without-congestion>#</a></h3><p>The figure 11-1 illustrates a standard Remote Direct Memory Access (RDMA) Write operation between two GPUs. This example demonstrates how GPU-0 on Host-1 transfers local gradients (∇₁ and ∇₂) from memory to GPU-0 on Host-2. Both GPUs use RDMA-capable NICs connected to Rail Switch A via 200 Gbps uplinks.</p><p>The RDMA Write operation proceeds through the following seven steps:</p><ol><li>To initiate the data transfer, GPU-0 on Host-1 submits a work request to its RDMA NIC over the PCIe bus over the pre-established Queue Pair 0x123456. </li><li>The RDMA NIC encodes the request by inserting the OpCode (RDMA Write) and Queue Pair Number (0x123456) into the InfiniBand Transport Header (IBTH). It wraps the IBTH and RETH (not shown in the figure) headers with Ethernet, IP, UDP, and Ethernet headers. The NIC sets the DSCP value to 24 and the ECN bits to 10 (indicating ECN-capable transport) in the IP header&rsquo;s ToS octet. The DSCP value ensures that the switch can identify and prioritize RoCEv2 traffic. The destination UDP port is set to 4791 (not shown in the figure).</li><li>Upon receiving the packet on interface Ethernet1/24, the Rail switch classifies the traffic as RoCEv2 based on the DSCP value of 24.</li><li>The switch maps DSCP 24 to QoS-Group 3.</li><li>QoS Group 3 uses egress priority queue 3, which is configured with bandwidth allocation and congestion avoidance parameters (WRED Min, WRED Max, and Drop thresholds) optimized for RDMA traffic. </li><li>The packet count on queue 3 does not exceed the WRED minimum threshold, so packets are forwarded without modification. </li><li>The RDMA NIC on Host-2 receives the packet, strips off the Ethernet, IP, and UDP headers, and processes the RDMA headers. The payload is delivered directly into the memory of GPU-0 on Host-2 without CPU involvement, completing the RDMA Write operation.</li></ol><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image1-1.png alt=img|320x271></p><p><strong>Figure 11-1:</strong> <em>Overview of Remote DMA operation Under Normal Condition.</em></p><h3 id=explicit-congestion-notification--ecn>Explicit Congestion Notification -ECN
<a class=anchor href=#explicit-congestion-notification--ecn>#</a></h3><p>Because gradient synchronization requires a lossless network service, it is essential to have a proactive congestion detection system that can respond before buffer overflows occur. This system must also include a signalling mechanism that allows the receiver to request the sender to reduce its transmission rate or temporarily pause traffic when necessary.</p><p>Data Center Quantized Congestion Notification (DCQCN) is a congestion control scheme designed for RoCEv2 that leverages both Explicit Congestion Notification (ECN) and Priority Flow Control (PFC) for active queue management. This section focuses on ECN.</p><p>In IPv4, the last two bits (bits 6 and 7) of the ToS (Type of Service) byte are reserved for ECN marking. With two bits, four ECN codepoints are defined:</p><p>00 – Not ECN-Capable Transport (Not-ECT)
01 – ECN-Capable Transport (ECT)
10 – ECN-Capable Transport (ECT)
11 – Congestion Experienced (CE)</p><p>Figure 11-2 illustrates how ECN is used to prevent packet drops when congestion occurs on egress interface Ethernet2/24. ECN operates based on two queue thresholds: WRED Minimum and WRED Maximum. When the queue depth exceeds the WRED Minimum but remains below the WRED Maximum, the switch begins to randomly mark forwarded packets with ECN 11 (Congestion Experienced). If the queue depth exceeds the WRED Maximum, all packets are marked with ECN 11. The Drop Threshold defines the upper limit beyond which packets are no longer marked but instead dropped.</p><p>In Figure 11-2, GPU-0 on Host-1 transfers gradient values from its local memory to the memory of GPU-0 on Host-2. Although not shown in the figure for simplicity, other GPUs connected to the same rail switch also participate in the synchronization process with GPU-0 on Host-2. Multiple simultaneous elephant flows towards GPU-0 reach the rail switch, causing egress queue 3 on interface Ethernet2/24 to exceed the WRED Maximum threshold. As a result, the switch begins marking outgoing packets with ECN 11 (step 6), while still forwarding them to the destination GPU. </p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image1-2.png alt=img|320x271></p><p><strong>Figure 11-2:</strong> <em>Congested Egress Interface – ECN Congestion Experienced.</em></p><p>After receiving a data packet marked with ECN 11, the destination RDMA NIC must inform the sender about network congestion. This is accomplished using a Congestion Notification Packet (CNP), which provides feedback at the RDMA transport layer. </p><ol><li>Upon detecting the ECN  11 in the IP header’s ToS bits of an incoming packet, the RDMA NIC on Host-2 generates a CNP message. It sets the OpCode in the IBTH header to 0x81, identifying the message as a CNP. Besides the FECN bit is set to 1, indicating that the NIC experienced congestion. The Queue Pair number used for the original memory copy (e.g., 0x123456) is reused, ensuring the feedback reaches the correct sender-side transport context. In the IP header, the DSCP field is set to 48, allowing switches to distinguish the CNP from standard RoCEv2 data traffic.</li><li>When the CNP reaches the Rail switch (interface Ethernet2/24), it is classified based on DSCP 48, which is associated with CNP traffic in the QoS configuration.</li><li>DSCP 48 maps the packet to QoS group 7, which is reserved for congestion feedback signaling.</li><li>QoS group 7 is associated with strict-priority egress queue 7, ensuring that CNP packets are forwarded with the highest priority. This guarantees that congestion signals are not delayed behind other types of traffic.</li><li>The switch forwards the CNP to the originating NIC on Host-1. Because of the strict-priority handling, the feedback arrives quickly even during severe congestion.</li><li>Upon receiving the CNP, the sender-side RDMA NIC reduces its transmission rate for the affected Queue Pair by increasing inter-packet delay. This is achieved by holding outgoing packets longer in local buffers, effectively reducing traffic injection into the congested fabric.</li></ol><p>As transmission rates decrease, the pressure on the egress queue at the Rail switch’s interface Ethernet1/14 (connected to Host-2) is gradually relieved. Buffer occupancy falls below the WRED Minimum Threshold, ending ECN marking. Once congestion is fully cleared, the RDMA NIC slowly ramp up its transmission rate. This gradual marking strategy helps prevent sudden traffic loss and gives the sender time to react by adjusting its sending rate before the buffer overflows.</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image1-3.png alt=img|320x271></p><p><strong>Figure 11-3:</strong> <em>Receiving NIC Generates CNP - Sender NIC Delay Transmit.</em></p><p>Next post describes DSCP-Based Priority Flow Control (PFC) use cases and operation.</p><h2 id=congestion-avoidance-in-ai-fabric---part-ii-priority-flow-control-pfc>Congestion Avoidance in AI Fabric - Part II: Priority Flow Control (PFC)
<a class=anchor href=#congestion-avoidance-in-ai-fabric---part-ii-priority-flow-control-pfc>#</a></h2><p>Priority Flow Control (PFC) is a mechanism designed to prevent packet loss during network congestion by pausing traffic selectively based on priority levels. While the original IEEE 802.1Qbb standard operates at Layer 2, using the Priority Code Point (PCP) field in Ethernet headers, AI Fabrics rely on Layer 3 forwarding, where traditional Layer 2-based PFC is no longer applicable. To extend lossless behavior across routed (Layer 3) networks, DSCP-based PFC is used.</p><p>In DSCP-based PFC, the Differentiated Services Code Point (DSCP) field in the IP header identifies the traffic class or priority. Switches map specific DSCP values to internal traffic classes and queues. If congestion occurs on an ingress interface and a particular priority queue fills beyond a threshold, the switch can send a PFC pause frame back to the sender switch, instructing it to temporarily stop sending traffic of that class—just as in Layer 2 PFC, but now triggered based on Layer 3 classifications.</p><p>This behavior differs from Explicit Congestion Notification (ECN), which operates at Layer 3 as well but signals congestion by marking packets instead of stopping traffic. ECN acts on the egress port, informing the receiver to notify the sender to reduce the transmission rate over time. In contrast, PFC acts immediately at the ingress port, pausing traffic flow in real time to avoid buffer overflows and packet drops.</p><p>PFC relies on two thresholds to control flow: xOFF and xON. The xOFF threshold defines the point at which the switch generates a pause frame when a priority queue reaches a congested state. Once triggered, upstream devices halt transmission of that traffic class. The switch continuously monitors its buffer occupancy, and when the level drops below the xON threshold, it sends a PFC frame with a Quanta value of 0 for the affected priority. This signals the upstream device that it can resume transmission for that specific priority queue.</p><p>A key requirement for PFC to function correctly is the provisioning of buffer headroom. The switch must reserve enough buffer space per priority class to accommodate in-flight traffic while the pause frame propagates to the sender and takes effect.</p><p>DSCP-based PFC enables lossless packet delivery over routed networks, which is especially important for technologies like RoCEv2 (RDMA over Converged Ethernet v2), where even minimal packet loss can cause significant performance degradation.</p><h3 id=dscp-based-pfc-process-over-a-layer-3-routed-interface-example-scenario>DSCP-Based PFC Process over a Layer 3 Routed Interface (Example Scenario)
<a class=anchor href=#dscp-based-pfc-process-over-a-layer-3-routed-interface-example-scenario>#</a></h3><p>This example illustrates how DSCP-based Priority Flow Control (PFC) operates across a routed Layer 3 fabric during congestion. We walk through a four-step process, beginning with buffer overflow and ending with traffic pausing on the correct priority queue.</p><h4 id=step-1-buffer-overflow-on-rail-switch-c-egress-to-gpu-3-host-3>Step 1: Buffer Overflow on Rail Switch C (Egress to GPU-3, Host 3)
<a class=anchor href=#step-1-buffer-overflow-on-rail-switch-c-egress-to-gpu-3-host-3>#</a></h4><p>In a GPU cluster, multiple GPUs are sending high-throughput RDMA traffic to GPU on Host-3. In Figure 11-4 Rail Switch C is responsible for forwarding traffic toward GPU-3. The egress interface on Switch C (E12/24) that connects to GPU-3 becomes congested. Due to the overflow of egress queue 3, packets from ingress queue 3 on interface E3/24 cannot be placed into egress queue 3.</p><h4 id=step-2-xoff-threshold-exceeded>Step 2: xOFF Threshold Exceeded
<a class=anchor href=#step-2-xoff-threshold-exceeded>#</a></h4><p>Priority queue 3  of has two configured thresholds:</p><ul><li>xOFF threshold: Triggers a pause when buffer usage exceeds this level. </li><li>xON threshold: Triggers a resume when the buffer has drained sufficiently.</li></ul><p>Once priority queue 3 on ingress interface E3/24 exceeds its xOFF threshold, the switch takes immediate action to prevent packet loss by generating a PFC pause message targeted at the sender. The sender in this case is Spine Switch 1, which is sending traffic to Rail Switch C, over interface E3/24, for delivery to GPU-3.</p><h4 id=step-3-generating-a-pfc-pause-frame-mac-control-frame>Step 3: Generating a PFC Pause Frame (MAC Control Frame)
<a class=anchor href=#step-3-generating-a-pfc-pause-frame-mac-control-frame>#</a></h4><p>To pause the sender, Rail Switch C generates an Ethernet MAC Control frame with:</p><ul><li><strong>Ethertype  0x8808</strong>: This indicates a MAC Control frame, used for pause-related operations (standardized in IEEE 802.3x). Inside this frame, a PFC opcode (0x0101) specifies it&rsquo;s a Priority-based Pause (PFC) message.</li><li><strong>Class Enable Vector (CEV)</strong>: This 8-bit field indicates which priority queues should be paused. Each bit corresponds to one of the 8 possible traffic classes (0–7). For example, if bit 3  is set to 1, it tells the sender to pause traffic for priority queue 3 only, while all other bits remain 0. In our case, the CEV is 0x1000. Note that the right-most bit represents queue 0.</li><li><strong>Quanta Field(s)</strong>: For each enabled priority (bit set to 1), a corresponding quanta value is specified. This value defines the duration of the pause, measured in units of 512 bit times.</li></ul><p>For a 400 Gbps interface:</p><ul><li>1 bit time = 1 / 400,000,000,000 seconds ≈ 2.5 picoseconds</li><li>1 quanta = 512 × 2.5 ps = 1.28 nanoseconds</li><li>If the pause quanta is set to maximum value 0xFFFF (65535), the pause duration is roughly 83.9 microseconds.</li></ul><p>This pause frame is sent back to the sender Spine Switch 1. Since the DSCP-based classification maps back to priority queue 3, and the switches share the same mapping, Spine Switch 1 will interpret this correctly.</p><h4 id=step-4-spine-switch-1-pauses-transmission-on-priority-queue-3>Step 4: Spine Switch 1 Pauses Transmission on Priority Queue 3
<a class=anchor href=#step-4-spine-switch-1-pauses-transmission-on-priority-queue-3>#</a></h4><p>Upon receiving the PFC frame on its ingress interface E3/24 connected to Rail Switch C, Spine Switch 1 examines the class enable vector.</p><ul><li>Since bit 3 is set, the switch knows to pause transmission of all frames mapped to priority queue 3 (DSCP value 24 in our example) on egress interface E3/24.</li></ul><p>Traffic for other priority queues continues unaffected. </p><p>Spine Switch 1 holds off transmission of priority 3 traffic until it receives a subsequent PFC frame with quanta = 0, indicating “resume,” or a pause duration timeout occurs, after which the switch resumes sending unless another pause is received.</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image2-1.png alt=img|320x271></p><p><strong>Figure 11-4:</strong> <em>Priority Flow Control – Pause Frame.</em></p><p>The following example shows how Priority Flow Control (PFC) events can cascade upstream when congestion persists in a routed Layer 3 fabric. This scenario builds on the earlier case, where Spine Switch 1 paused traffic to Rail Switch C. Now, we observe how that pause affects traffic originating from Rail Switches A and B.</p><h4 id=step-5-congestion-on-spine-switch-1-egress-queue-to-rail-switch-c>Step 5: Congestion on Spine Switch 1 Egress Queue to Rail Switch C
<a class=anchor href=#step-5-congestion-on-spine-switch-1-egress-queue-to-rail-switch-c>#</a></h4><p>As described in the previous figure, Spine Switch 1 received a PFC frame from Rail Switch C and responded by pausing traffic on priority queue 3 on its egress interface E3/24 (towards Rail Switch C). Because this interface is no longer sending traffic, frames destined for GPU-3 via Rail Switch C begin to accumulate in Spine Switch 1’s egress queue 3. This build-up causes backpressure that impacts the ingress side of the switch.</p><h4 id=step-6-xoff-threshold-exceeded-on-spine-switch-1-ingress-interfaces>Step 6: xOFF Threshold Exceeded on Spine Switch 1 Ingress Interfaces
<a class=anchor href=#step-6-xoff-threshold-exceeded-on-spine-switch-1-ingress-interfaces>#</a></h4><p>Spine Switch 1 receives incoming traffic from Rail Switch A (interface E1/24) and Rail Switch B (interface E2/24). Both switches are sending traffic mapped to priority queue 3 (e.g., DSCP 24). As the egress queue to Rail Switch C becomes full and cannot drain, the corresponding ingress buffers on interfaces E1/24 and E2/24 also begin to fill up, specifically for queue 3. Eventually, the xOFF thresholds on both ingress interfaces are exceeded, indicating that congestion is now impacting the reception of new packets on these ports.</p><h4 id=step-7-spine-switch-1-sends-pfc-pause-frames-to-rail-switch-a-and-b>Step 7: Spine Switch 1 Sends PFC Pause Frames to Rail Switch A and B
<a class=anchor href=#step-7-spine-switch-1-sends-pfc-pause-frames-to-rail-switch-a-and-b>#</a></h4><p>To avoid dropping packets due to ingress buffer overflow, Spine Switch 1 generates PFC MAC Control frames on both E1/24 and E2/24. The class enable vector has bit 3 set, instructing the sender to pause traffic corresponding to priority queue 3. A suitable quanta value is included to define the pause duration. These control frames travel back to Rail Switch A and Rail Switch B respectively.</p><h4 id=step-8-rail-switches-a-and-b-pause-queue-3-traffic-to-spine-switch-1>Step 8: Rail Switches A and B Pause Queue 3 Traffic to Spine Switch 1
<a class=anchor href=#step-8-rail-switches-a-and-b-pause-queue-3-traffic-to-spine-switch-1>#</a></h4><p>Upon receiving the PFC frames, both Rail Switch A and Rail Switch B interpret the class enable vector and pause all traffic mapped to priority queue 3 (e.g., DSCP 24),  still forwarding traffic on other priority queues unaffected. This marks the upstream propagation of congestion: a single bottleneck on the path to GPU-3 can trigger PFC reactions all the way back to multiple source switches.</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image2-2.png alt=img|320x271></p><p>Figure 11-5: Priority Flow Control – Cascading Effect.</p><h4 id=steps-9a--14-downstream-resume-and-congestion-recovery>Steps 9a – 14: Downstream Resume and Congestion Recovery
<a class=anchor href=#steps-9a--14-downstream-resume-and-congestion-recovery>#</a></h4><p>Figure 11-6 illustrates how the PFC-based congestion recovery process extends from Rail Switches A and B all the way to the GPU NICs, while simultaneously resolving the initial congestion at Rail Switch C.</p><p>As a result of the earlier PFC pause frames:</p><ul><li>Rail Switch A and Rail Switch B have paused sending priority queue 3 traffic to Spine Switch 1.</li><li>In turn, Spine Switch 1 has paused its own egress traffic toward Rail Switch C on interface E3/24.</li></ul><p>This pause allows queue 3 on Rail Switch C’s egress interface E12/24 (toward GPU-3) to drain, as no new traffic is arriving, and the GPU continues to consume incoming data.</p><p>Once the buffer utilization for priority queue 3 drops below the configured xON threshold, Rail Switch C initiates congestion recovery.</p><ul><li>It sends a MAC Control Frame (Ethertype 0x8808) back to Spine Switch 1.</li><li>The class enable vector has bit 3 set (indicating priority queue 3).</li><li>The quanta value is set to 0, signaling that it is now safe to resume transmission.</li></ul><p>Upon receiving this resume message, Spine Switch 1 can begin sending traffic again on priority queue 3, restoring throughput toward GPU-3 and continuing the flow of RDMA traffic through the network. This recovery mechanism operates consistently across the entire AI fabric.</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image2-3.png alt=img|320x271></p><p>Figure 11-6: Priority Flow Control – PCIe Bus Congested: Cascading Effect.</p><h3 id=lldp-with-dcbx>LLDP with DCBX
<a class=anchor href=#lldp-with-dcbx>#</a></h3><p>PFC negotiation is performed using the Link Layer Discovery Protocol (LLDP), which carries Data Center Bridging eXchange (DCBX) Type-Length-Value (TLV) structures. At the time of writing, DCBX exists in two versions: IEEE and CEE. The IEEE mode (defined in 802.1Qbb and 802.1Qaz) is standards-based and supported by most modern data center switches from various vendors. This mode is also known as DCBXv2. Some older Cisco Nexus models support only the Cisco/Converged Enhanced Ethernet (CEE) mode. Capture 11-1 shows the packet format of a standards-based IEEE DCBX TLV within an LLDP message.</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image2-4.png alt=img|320x271></p><p>Capture 11-1: PCF: LLDP with IEEE DBCXv2 TLV .</p><h2 id=congestion-avoidance-in-ai-fabric---part-iii-data-center-quantized-congestion-notification-dcqcn>Congestion Avoidance in AI Fabric - Part III: Data Center Quantized Congestion Notification (DCQCN)
<a class=anchor href=#congestion-avoidance-in-ai-fabric---part-iii-data-center-quantized-congestion-notification-dcqcn>#</a></h2><p>Data Center Quantized Congestion Notification (DCQCN) is a hybrid congestion control method. DCQCN brings together both Priority Flow Control (PFC) and Explicit Congestion Notification (ECN) so that we can get high throughput, low latency, and lossless delivery across our AI fabric. In this approach, each mechanism plays a specific role in addressing different aspects of congestion, and together they create a robust flow-control system for RDMA traffic.</p><p>DCQCN tackles two main issues in large-scale RDMA networks:</p><ol><li>Head-of-Line Blocking and Congestion Spreading: This is caused by PFC’s pause frames, which stop traffic across switches.</li><li>Throughput Reduction with ECN Alone: When the ECN feedback is too slow, packet loss may occur despite the rate adjustments.</li></ol><p>DCQCN uses a two-tiered approach. It applies ECN early on to gently reduce the sending rate at the GPU NICs, and it uses PFC as a backup to quickly stop traffic on upstream switches (hop-by-hop) when congestion becomes severe.</p><h3 id=how-dcqcn-combines-ecn-and-pfc>How DCQCN Combines ECN and PFC
<a class=anchor href=#how-dcqcn-combines-ecn-and-pfc>#</a></h3><p>DCQCN carefully combines Explicit Congestion Notification (ECN) and Priority Flow Control (PFC) in the right sequence:</p><p><strong>Early Action with ECN:</strong> When congestion begins to build up, the switch uses WRED thresholds (minimum and maximum) to mark packets. This signals the sender to gradually reduce its transmission rate. As a result, the GPU NIC slows down, and traffic continues flowing—just at a reduced pace—without abrupt pauses.</p><p><strong>Backup Action with PFC:</strong> If congestion worsens and the queue continues to grow, the buffer may reach the xOFF threshold. At this point, the switch sends PFC pause frames hop by hop to upstream devices. These devices respond by temporarily stopping traffic for that specific priority queue, helping prevent packet loss.</p><p><strong>Resuming Traffic:</strong> Once the buffer has drained and the queue drops below the xON threshold, the switch sends a resume message (a PFC frame with a quanta value of 0). This tells the upstream device it can start sending traffic again.</p><h3 id=why-ecn-must-precede-xoff>Why ECN Must Precede xOFF
<a class=anchor href=#why-ecn-must-precede-xoff>#</a></h3><p>It is very important that the ECN thresholds (WRED minimum and maximum) are used before the xOFF threshold is reached for three main reasons:</p><p><strong>Graceful Rate Adaptation:</strong> Early ECN marking helps the GPU NIC (sender) reduce its transmission rate gradually. This smooth adjustment avoids sudden stops and leads to more stable traffic flows.</p><p><strong>Avoiding Unnecessary PFC Events:</strong> If the sender adjusts its rate early with ECN feedback, the buffers are less likely to fill up to the xOFF level. This avoids the need for abrupt PFC pause frames that can cause head-of-line blocking and backpressure on the network.</p><p><strong>Maintaining Fabric Coordination:</strong> With early ECN marking, the sender receives feedback before congestion becomes severe. While the ECN signal is not shared directly with other switches, the sender&rsquo;s rate adjustment helps reduce overall pressure on the network fabric.</p><h3 id=what-happens-if-xoff-is-reached-before-ecn-marking>What Happens If xOFF Is Reached Before ECN Marking?
<a class=anchor href=#what-happens-if-xoff-is-reached-before-ecn-marking>#</a></h3><p>Imagine that the ingress queue on Spine Switch 1 (from Rail Switch A) fills rapidly without ECN marking:</p><p><strong>Sudden Pause:</strong> The buffer may quickly hit the xOFF threshold and trigger an immediate PFC pause.</p><p><strong>Downstream Effects:</strong> An abrupt stop in traffic from Rail Switch A leads to sudden backpressure. This can cause head-of-line blocking and disturb GPU communication, leading to performance jitter or instability at the application level.</p><p><strong>Oscillations:</strong> When the queue finally drains and reaches the xON threshold, traffic resumes suddenly. This can cause recurring congestion and stop-and-go patterns that hurt overall performance.</p><p>By allowing ECN to mark packets early, the network gives the sender time to reduce its rate smoothly. This prevents abrupt stops and helps maintain a stable, efficient fabric.</p><p>Figure 11 recaps how the example DCQCN process works:</p><p><strong>Time t1:</strong> (1) Traffic associated with priority queue 3 on Rail-1’s egress interface 1 crosses the WRED minimum threshold.</p><p><strong>Time t2:</strong> (2) Rail-1 begins randomly marking ECN bits as 11 on packets destined for GPU-0 on the Host-3.</p><p><strong>Time t3:</strong> (3) The RDMA NIC starts sending CNP messages to the sender GPU-1 on Host-1.</p><p><strong>Time t4:</strong> (4) In response to the CNP message, the sending GPU-0 on Host-1 reduces its transmission rate by holding packets longer in its egress queue. (5) At the same time, egress queue 3 on Rail-1 remains congested. (6) Since packets cannot be forwarded from ingress interface 2 to egress interface 1’s queue 3, ingress interface 3 also becomes congested, eventually crossing the PFC xOFF threshold.</p><p><strong>Time t5:</strong> (7) As a result, Rail-1 sends a PFC xOFF message to Spine-A over Inter-Switch Link 3. (8) In response, Spine-A halts forwarding traffic for the specified pause duration.</p><p><strong>Time t6:</strong> (9) Due to the forwarding pause, the egress queue of interface 3 on Spine-A becomes congested, which in turn (10) causes congestion on its ingress interface 2.</p><p><strong>Time t7:</strong> (11) The number of packets waiting in egress queue 3 on interface 1 of Rail-1 drops below the WRED minimum threshold. (12) This allows packets from the buffer of interface 3 to be forwarded.</p><p><strong>Time t8:</strong> (13) The packet count on ingress interface 3 of Rail-1 falls below the PFC xON threshold, triggering the PFC resume/unpause message to Spine-A. (14) Spine-A resumes forwarding traffic to Rail-1.</p><p>After the PFC resume message is sent, Spine-A starts forwarding traffic again toward Rail-1. The congestion on Spine-A’s interface 3 gets cleared as packets leave the buffer. This also helps the ingress interface 2 on Spine-A to drain. On Rail-1, as interface 1 can now forward packets, queue 3 gets more room, and the flow to GPU-0 becomes smoother again.</p><p>The RDMA NIC on the sender GPU monitors the situation. Since there are no more CNP messages coming in, the GPU slowly increases its sending rate. At the same time, the ECN marking on Rail-1 stops, as queue lengths stay below the WRED threshold. Traffic flow returns to normal, and no more PFC pause messages are needed.</p><p>The whole system stabilizes, and data can move again without delay or packet loss.</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image3-1.png alt=img|320x271></p><p>Figure 11-7: DCQCN: ECN and PFC Interaction .</p><h3 id=dcqcn-configuration>DCQCN Configuration
<a class=anchor href=#dcqcn-configuration>#</a></h3><p>Figure 11-8 shows the six steps to enable DCQCN on a switch. The figure assumes that the RDMA NIC marks RoCEv2 traffic with DSCP 24.</p><p>First, we classify the packets based on the DSCP value in the IPv4 header. Packets marked with DSCP 24 are identified as RoCEv2 packets, while packets marked with DSCP 48 are classified as CNP.</p><p>After classification, we add an internal QoS label to the packets to place them in the correct output queue. The mapping between internal QoS labels and queues is fixed and does not require configuration.</p><p>Next, we define the queue type, allocate bandwidth, and set ECN thresholds. After scheduling is configured, we enable PFC and set its threshold values. A common rule of thumb for the relationship between ECN and PFC thresholds is: xON &lt; WRED Min &lt; WRED Max &lt; xOFF.</p><p>To apply these settings, we enable them at the system level. Finally, we apply the packet classification to the ingress interface and enable the PFC watchdog on the egress interface. Because PFC is a sub-TLV in the LLDP Data Unit (LLDPDU), both LLDP and PFC must be enabled on every inter-switch link.</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/ai-ml-dc/congestion-avoidance/image3-2.png alt=img|320x271></p><p><strong>Figure 11-8:</strong> <em>Applying DCQCN to Switch.</em></p><h4 id=step-1-packet-classification>Step 1: Packet Classification
<a class=anchor href=#step-1-packet-classification>#</a></h4><p>The classification configuration is used to identify different types of traffic based on their DSCP values. In our example we have one for RoCEv2 traffic and another for Congestion Notification Packets (CNP). The “class-map type qos match-any ROCEv2” line defines a class map named “ROCEv2” that matches any packet marked with DSCP value 24, which is commonly used for RDMA traffic. Similarly, the “class-map type qos match-any CNP” defines another class map named “CNP” that matches packets marked with DSCP value 48, typically used for congestion signaling in RDMA environments. These class maps serve as the foundation for downstream policies, enabling differentiated handling of traffic types. Note that the names “ROCEv2” and “CNP” are not system-reserved; they are simply user-defined labels that can be renamed, as long, as the references are consistent throughout the configuration.</p><pre tabindex=0><code>class-map type qos match-any ROCEv2 
  match dscp 24
class-map type qos match-any CNP 
  match dscp 48
</code></pre><p><strong>Example 11-1:</strong> <em>Classification.</em></p><h4 id=step-2-internal-qos-label-for-queueing>Step 2: Internal QoS Label for Queueing
<a class=anchor href=#step-2-internal-qos-label-for-queueing>#</a></h4><p>The marking configuration assigns internal QoS labels to packets that have already been classified. This is done using a policy map named QOS_CLASSIFICATION, which refers to the previously defined class maps. Within this policy, packets that match the “ROCEv2” class are marked with qos-group 3, and those matching the “CNP” class are marked with  qos-group 7. Any other traffic that doesn&rsquo;t fit these two categories falls into the default class and is marked with qos-group 0. These QoS groups are internal identifiers that the switch uses in later stages for  queuing and scheduling, to decide how each packet should be treated. Just like class maps, the name of the policy map itself is user-defined and can be anything descriptive, provided it is correctly referenced in other parts of the configuration. </p><pre tabindex=0><code>policy-map type qos QOS_CLASSIFICATION 
  class ROCEv2
    set qos-group 3
  class CNP
    set qos-group 7
  class class-default
    set qos-group 0
</code></pre><p><strong>Example 11-2:</strong> <em>Marking.</em></p><h4 id=step-3-scheduling>Step 3: Scheduling
<a class=anchor href=#step-3-scheduling>#</a></h4><p>The queuing configuration defines how traffic is scheduled and prioritized on the output interfaces, based on the internal QoS groups that were assigned earlier. This is handled by a policy map named “QOS_EGRESS_PORT,” which maps traffic to different hardware output queues. Each queue is identified by a class, such as c-out-8q-q7 (fixed names: 8q = eight queues, q7 = queue number 7). For example, queue 7 is configured with priority level 1, which gives it strict priority over all other traffic. Queue 3 is assigned bandwidth remaining percent 50, meaning that it is guaranteed half of the remaining bandwidth after strict-priority traffic has been serviced. In addition to bandwidth allocation, queue 3 includes congestion management features through the random-detect command. This enables Weighted Random Early Detection (WRED), a mechanism that helps avoid congestion by randomly mark  packets as queue depth increases. The minimum-threshold and maximum-threshold define the WRED minimum and maximum values (from 150 KB to 3000 KB) at which packets begin marked. The drop-probability 7 determines the likelihood of packet mark when the maximum threshold is reached, with higher numbers indicating higher marking rates. The weight 0 setting controls how queue size is averaged. A weight of 0 means use instantaneous queue depth (no averaging). Finally, ecn enables Explicit Congestion Notification, allowing network devices to signal congestion without dropping packets, without the ecn option switch drops packet based on WRED min/max values. The remaining queues are configured with either zero percent of remaining bandwidth, effectively disabling them for general use, or with a share of the remaining bandwidth. This queuing policy ensures that RoCEv2 traffic receives adequate resources with congestion feedback, while CNP messages always get through with strict priority.</p><pre tabindex=0><code>policy-map type queuing QOS\_EGRESS\_PORT
  class type queuing c-out-8q-q6
    bandwidth remaining percent 0
  ...

  class type queuing c-out-8q-q3
    bandwidth remaining percent 50
    random-detect minimum-threshold 150 kbytes maximum-threshold 3000 kbytes drop-probability 7 weight 0 ecn
  ...

  class type queuing c-out-8q-q7
    priority level 1 
</code></pre><p><strong>Example 11-3:</strong> <em>Queuing (Output Scheduling).</em></p><h4 id=step-4-enable-pfc-for-queue>Step 4: Enable PFC for Queue
<a class=anchor href=#step-4-enable-pfc-for-queue>#</a></h4><p>The Network QoS configuration defines the low-level, hardware-based characteristics of traffic handling within the switch, such as enabling lossless behavior and setting the maximum transmission unit (MTU) size for each traffic class. In this example, the policy-map type network-qos qos_network is used to configure how traffic is handled inside the switch fabric. Under this policy, the class type network-qos c-8q-nq3 is associated with pause pfc-cos 3, which enables Priority Flow Control (PFC) on Class of Service (CoS) 3. This is critical for RoCEv2 traffic, which depends on a lossless transport layer. The MTU is also defined here, with bytes (jumbo frame) set for class 3 traffic.</p><pre tabindex=0><code>policy-map type network-qos qos\_network
  class type network-qos c-8q-nq3
   mtu 9216    
   pause pfc-cos 3   
</code></pre><p><strong>Example 11-4:</strong> <em>Queuing (Output Scheduling).</em></p><h4 id=priority-flow-control-watchdog>Priority Flow Control Watchdog
<a class=anchor href=#priority-flow-control-watchdog>#</a></h4><p>The Priority Flow Control (PFC) watchdog is a mechanism that protects the network from traffic deadlocks caused by stuck PFC pause frames. In RDMA environments like RoCEv2, PFC is used to create lossless classes of traffic by pausing traffic flows instead of dropping packets. However, if a device fails to release the pause or a misconfiguration causes PFC frames to persist, traffic in the affected class can become permanently blocked, leading to what is called a &ldquo;head-of-line blocking&rdquo; condition. To mitigate this risk, the priority-flow-control watch-dog-interval on command enables the PFC watchdog feature. When enabled, the switch monitors traffic in each PFC-enabled queue for signs of persistent pause conditions. If it detects that traffic has been paused for too long, indicating a potential deadlock, it can take corrective actions, such as generating logs, resetting internal counters, or even discarding paused traffic to restore flow. </p><pre tabindex=0><code>priority-flow-control watch-dog-interval on
</code></pre><p><strong>Example 11-5:</strong> <em>Priority Flow Control (PFC) Watchdog.</em></p><h4 id=step-5-bind-and-apply-qos-settings>Step 5: Bind and Apply QoS Settings
<a class=anchor href=#step-5-bind-and-apply-qos-settings>#</a></h4><p>System-level QoS policies bind all the previously defined QoS components together and activate them across the switch. This is done using the system qos configuration block, which applies the appropriate policy maps globally. The service-policy type network-qos qos_network command activates the network-qos policy defined earlier, ensuring that MTU sizes and PFC configurations are enforced across the switch fabric. The command service-policy type queuing output QOS_EGRESS_PORT applies the queuing policy at the output interface level, enabling priority queuing, bandwidth allocation, and congestion management as traffic exits the switch. These system-level bindings are essential because, without them, the individual QoS policies, classification, marking, queuing, and fabric-level configuration, would remain inactive. By applying the policies under system qos, the switch is instructed to treat traffic according to the rules and priorities defined in each policy map. This final step ensures end-to-end consistency in QoS behavior, from ingress classification to fabric transport and egress scheduling, providing a complete and operational quality-of-service framework tailored for latency-sensitive, lossless applications like RoCEv2.</p><pre tabindex=0><code>system qos
  service-policy type network-qos qos\_network
  service-policy type queuing output QOS\_EGRESS\_PORT
</code></pre><p><strong>Example 11-6:</strong> <em>Priority Flow Control (PFC) Watchdog.</em></p><p>Step 6: Interface-Level Configuration </p><p>The interface-level configuration attaches the previously defined QoS policies and enables PFC-specific features for a given port. In our example, the configuration is applied to Ethernet2/24, but the same approach can be used for any interface where you need to enforce QoS and PFC settings. The first command, priority-flow-control mode auto, enables Priority Flow Control (PFC) on the interface in auto-negotiation mode. This means the interface will automatically negotiate PFC with its link partner, allowing for lossless traffic handling by pausing specific traffic classes instead of dropping packets. The priority-flow-control watch-dog command enables the PFC watchdog for this interface, which ensures that if any PFC pause frames are stuck or persist for too long, the watchdog will take corrective action to prevent a deadlock situation. This helps maintain the overall health of the network by preventing traffic congestion or blockages due to PFC-related issues. Lastly, the service-policy type qos input QOS_CLASSIFICATION command applies the QoS classification policy on incoming traffic, ensuring that packets are classified and marked according to their DSCP values as defined in the QOS_CLASSIFICATION policy. This classification enables downstream QoS treatment, including proper queuing, scheduling, and priority handling. </p><pre tabindex=0><code>interface Ethernet 2/24
  priority-flow-control mode auto
  priority-flow-control watch-dog
  service-policy type qos input QOS\_CLASSIFICATION
</code></pre><p><strong>Example 11-7:</strong> <em>Interface Level Configuration.</em></p><p><strong>References:</strong></p><ul><li><a href=https://nwktimes.blogspot.com/2025/04/congestion-avoidance-ai-fabric-part-i.html>https://nwktimes.blogspot.com/2025/04/congestion-avoidance-ai-fabric-part-i.html</a></li><li><a href=https://nwktimes.blogspot.com/2025/04/congestion-avoidance-in-ai-fabric-part.html>https://nwktimes.blogspot.com/2025/04/congestion-avoidance-in-ai-fabric-part.html</a></li><li><a href=https://nwktimes.blogspot.com/2025/04/congestion-avoidance-in-ai-fabric-part_15.html>https://nwktimes.blogspot.com/2025/04/congestion-avoidance-in-ai-fabric-part_15.html</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/prmanna/tech-book/commit/e8963ed066cdc933f3e931a0c12713b697c62224 title='Last modified by Prasenjit Manna | April 28, 2025' target=_blank rel=noopener><img src=/tech-book/svg/calendar.svg class=book-icon alt>
<span>April 28, 2025</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#congestion-avoidance-in-ai-fabric---part-i-explicit-congestion-notification-ecn>Congestion Avoidance in AI Fabric - Part I: Explicit Congestion Notification (ECN)</a><ul><li><a href=#gpu-to-gpu-rdma-write-without-congestion>GPU-to-GPU RDMA Write Without Congestion</a></li><li><a href=#explicit-congestion-notification--ecn>Explicit Congestion Notification -ECN</a></li></ul></li><li><a href=#congestion-avoidance-in-ai-fabric---part-ii-priority-flow-control-pfc>Congestion Avoidance in AI Fabric - Part II: Priority Flow Control (PFC)</a><ul><li><a href=#dscp-based-pfc-process-over-a-layer-3-routed-interface-example-scenario>DSCP-Based PFC Process over a Layer 3 Routed Interface (Example Scenario)</a></li><li><a href=#lldp-with-dcbx>LLDP with DCBX</a></li></ul></li><li><a href=#congestion-avoidance-in-ai-fabric---part-iii-data-center-quantized-congestion-notification-dcqcn>Congestion Avoidance in AI Fabric - Part III: Data Center Quantized Congestion Notification (DCQCN)</a><ul><li><a href=#how-dcqcn-combines-ecn-and-pfc>How DCQCN Combines ECN and PFC</a></li><li><a href=#why-ecn-must-precede-xoff>Why ECN Must Precede xOFF</a></li><li><a href=#what-happens-if-xoff-is-reached-before-ecn-marking>What Happens If xOFF Is Reached Before ECN Marking?</a></li><li><a href=#dcqcn-configuration>DCQCN Configuration</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>