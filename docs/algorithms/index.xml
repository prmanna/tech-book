<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Technical Book</title><link>https://prasenjitmanna.com/tech-book/docs/algorithms/</link><description>Recent content in Algorithms on Technical Book</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://prasenjitmanna.com/tech-book/docs/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Depth First Search</title><link>https://prasenjitmanna.com/tech-book/docs/algorithms/depth-first-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://prasenjitmanna.com/tech-book/docs/algorithms/depth-first-search/</guid><description>Depth First Search # The pre-order traversal of a tree is DFS.
Node&amp;lt;int&amp;gt;* dfs(Node&amp;lt;int&amp;gt;* root, int target) { if (root == nullptr) return nullptr; if (root-&amp;gt;val == target) return root; // return non-null return value from the recursive calls Node&amp;lt;int&amp;gt;* left = dfs(root-&amp;gt;left, target); if (left != nullptr) return left; // at this point, we know left is null, and right could be null or non-null // we return right child&amp;#39;s recursive call result directly because // - if it&amp;#39;s non-null we should return it // - if it&amp;#39;s null, then both left and right are null, we want to return null return dfs(root-&amp;gt;right, target); } Max depth of a binary tree # Max depth of a binary tree is the longest root-to-leaf path.</description></item><item><title>Easy Complexity</title><link>https://prasenjitmanna.com/tech-book/docs/algorithms/easy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://prasenjitmanna.com/tech-book/docs/algorithms/easy/</guid><description> Easy Complexity #</description></item><item><title>Two Pointers &amp; Sliding Window</title><link>https://prasenjitmanna.com/tech-book/docs/algorithms/two-pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://prasenjitmanna.com/tech-book/docs/algorithms/two-pointers/</guid><description>Two Pointers # Valid Palindrome # Determine whether a string is a palindrome, ignoring non-alphanumeric characters and case. Examples:
Input: Do geese see God? Output: True
Input: Was it a car or a cat I saw? Output: True
Input: A brown fox jumping over Output: False
#include &amp;lt;cctype&amp;gt; // isalnum, tolower #include &amp;lt;iostream&amp;gt; // boolalpha, cin, cout #include &amp;lt;string&amp;gt; // getline bool is_palindrome(std::string s) { int l = 0, r = s.</description></item><item><title>Medium Complexity</title><link>https://prasenjitmanna.com/tech-book/docs/algorithms/medium/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://prasenjitmanna.com/tech-book/docs/algorithms/medium/</guid><description>Medium Complexity # Number Swapper: Write a function to swap a number in place (that is, without temporary variables). Hints - with just addition/substruction arithmatic, XOR.
Tic Tac Win: Design an algorithm to figure out if someone has won a game of tic-tac-toe.
Hashing # Two Sum: Find a pair in array whose sum equals to the target input: [10,4,1,3,2] Target: 7 Output: [4,3]
Hint - insert in hash and then start searching from first element, find the difference with the target and find the hash.</description></item></channel></rss>