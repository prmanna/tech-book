<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  1. Gathering System Requirements
  #

As with any systems design interview question, the first thing that we want to do is to gather system requirements; we need to figure out what system we&rsquo;re building exactly.
We&rsquo;re designing the core communication system behind Slack, which allows users to send instant messages in Slack channels.
Specifically, we&rsquo;ll want to support:

Loading the most recent messages in a Slack channel when a user clicks on the channel.
Immediately seeing which channels have unread messages for a particular user when that user loads Slack.
Immediately seeing which channels have unread mentions of a particular user, for that particular user, when that user loads Slack, and more specifically, the number of these unread mentions in each relevant channel.
Sending and receiving Slack messages instantly, in real time.
Cross-device synchronization: if a user has both the Slack desktop app and the Slack mobile app open, with an unread channel in both, and if they read this channel on one device, the second device should immediately be updated and no longer display the channel as unread.

The system should have low latencies and high availability, catering to a single region of roughly 20 million users. The largest Slack organizations will have as many as 50,000 users, with channels of the same size within them."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://prasenjitmanna.com/tech-book/docs/systemdesign-tips/design-slack/"><meta property="og:site_name" content="Technical Book"><meta property="og:title" content="Design Slack"><meta property="og:description" content=" 1. Gathering System Requirements # As with any systems design interview question, the first thing that we want to do is to gather system requirements; we need to figure out what system we’re building exactly.
We’re designing the core communication system behind Slack, which allows users to send instant messages in Slack channels.
Specifically, we’ll want to support:
Loading the most recent messages in a Slack channel when a user clicks on the channel. Immediately seeing which channels have unread messages for a particular user when that user loads Slack. Immediately seeing which channels have unread mentions of a particular user, for that particular user, when that user loads Slack, and more specifically, the number of these unread mentions in each relevant channel. Sending and receiving Slack messages instantly, in real time. Cross-device synchronization: if a user has both the Slack desktop app and the Slack mobile app open, with an unread channel in both, and if they read this channel on one device, the second device should immediately be updated and no longer display the channel as unread. The system should have low latencies and high availability, catering to a single region of roughly 20 million users. The largest Slack organizations will have as many as 50,000 users, with channels of the same size within them."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-05-08T22:54:13+05:30"><title>Design Slack | Technical Book</title>
<link rel=manifest href=/tech-book/manifest.json><link rel=icon href=/tech-book/favicon.png><link rel=canonical href=https://prasenjitmanna.com/tech-book/docs/systemdesign-tips/design-slack/><link rel=stylesheet href=/tech-book/book.min.a61cdb2979f3c2bece54ef69131fba427dd57d55c232d3bb5fdb62ac41aa8354.css integrity="sha256-phzbKXnzwr7OVO9pEx+6Qn3VfVXCMtO7X9tirEGqg1Q=" crossorigin=anonymous><script defer src=/tech-book/fuse.min.js></script><script defer src=/tech-book/en.search.min.704591c29afe892fab060def68d7f56e246c02dfd61187df42d0e4887cedb346.js integrity="sha256-cEWRwpr+iS+rBg3vaNf1biRsAt/WEYffQtDkiHzts0Y=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/tech-book/><img src=/tech-book/logo.png alt=Logo><span>Technical Book</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-99f552133860bc21797a47fe73e93434 class=toggle>
<label for=section-99f552133860bc21797a47fe73e93434 class="flex justify-between"><a href=/tech-book/docs/5g/>5G</a></label><ul><li><input type=checkbox id=section-dfc790b73acb0410a0114547cbf5af32 class=toggle>
<label for=section-dfc790b73acb0410a0114547cbf5af32 class="flex justify-between"><a href=/tech-book/docs/5g/5g-intro/>An Overview of 5G Networking</a></label></li></ul></li><li><input type=checkbox id=section-7c4a3b16aeeb5b7194b232c1eef2f4fb class=toggle>
<label for=section-7c4a3b16aeeb5b7194b232c1eef2f4fb class="flex justify-between"><a href=/tech-book/docs/algorithms/>Algorithms</a></label><ul><li><input type=checkbox id=section-8956d82fbe6869140758f7e8679174bc class=toggle>
<label for=section-8956d82fbe6869140758f7e8679174bc class="flex justify-between"><a href=/tech-book/docs/algorithms/breadth-first-search/>Breadth First Search</a></label></li><li><input type=checkbox id=section-5a049cfad1740f3fd30565524385fa57 class=toggle>
<label for=section-5a049cfad1740f3fd30565524385fa57 class="flex justify-between"><a href=/tech-book/docs/algorithms/depth-first-search/>Depth First Search</a></label></li><li><input type=checkbox id=section-ebc049f26d82165be8c6f1f9e504e799 class=toggle>
<label for=section-ebc049f26d82165be8c6f1f9e504e799 class="flex justify-between"><a href=/tech-book/docs/algorithms/easy/>Easy Complexity</a></label></li><li><input type=checkbox id=section-1071946392bd1f431993e950147fa054 class=toggle>
<label for=section-1071946392bd1f431993e950147fa054 class="flex justify-between"><a href=/tech-book/docs/algorithms/priority-queue-and-heap/>Priority Queue and Heap</a></label></li><li><input type=checkbox id=section-08afbeb294c43ca4908c1c89a4be9d0a class=toggle>
<label for=section-08afbeb294c43ca4908c1c89a4be9d0a class="flex justify-between"><a href=/tech-book/docs/algorithms/two-pointers/>Two Pointers & Sliding Window</a></label></li><li><input type=checkbox id=section-ef36c7c4f7e0dec6525068c3c409100c class=toggle>
<label for=section-ef36c7c4f7e0dec6525068c3c409100c class="flex justify-between"><a href=/tech-book/docs/algorithms/medium/>Medium Complexity</a></label></li></ul></li><li><input type=checkbox id=section-8c7c5c4a8382299873178820b1d91be1 class=toggle>
<label for=section-8c7c5c4a8382299873178820b1d91be1 class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/>Data Center Networking for AI Clusters</a></label><ul><li><input type=checkbox id=section-433ccede4154db01f6c601940d2949e0 class=toggle>
<label for=section-433ccede4154db01f6c601940d2949e0 class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/1-ai-ml-networking/>AI/ML Networking</a></label></li><li><input type=checkbox id=section-65f71f2455a94ea3d1143666d556b0ed class=toggle>
<label for=section-65f71f2455a94ea3d1143666d556b0ed class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/2-ai-deep-learning-basics/>Deep Learning Basics | Artificial Neuron</a></label></li><li><input type=checkbox id=section-af7b72510cdccfb9feb048bbf70c6f27 class=toggle>
<label for=section-af7b72510cdccfb9feb048bbf70c6f27 class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/2-1-large-language-models/>Large Language Models (LLM)</a></label></li><li><input type=checkbox id=section-b3eb6a6d3a1b87cba26dcfbb99658303 class=toggle>
<label for=section-b3eb6a6d3a1b87cba26dcfbb99658303 class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/2-2-parallelism-strategies-in-deep-learning/>Parallelism Strategies in Deep Learning</a></label></li><li><input type=checkbox id=section-f11d3aa2e337730e1e3345f8530fe134 class=toggle>
<label for=section-f11d3aa2e337730e1e3345f8530fe134 class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/3-challenges-in-ai-fabric/>Challenges in AI Fabric Design</a></label></li><li><input type=checkbox id=section-e28420ec7507646128f3695b6f9badbb class=toggle>
<label for=section-e28420ec7507646128f3695b6f9badbb class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/4-congestion-avoidance-in-ai-fabric/>Congestion Avoidance in AI Fabric</a></label></li><li><input type=checkbox id=section-67bb7cbb1dd95e59f8515201219c090f class=toggle>
<label for=section-67bb7cbb1dd95e59f8515201219c090f class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/5-load-balancing-in-ai-fabric/>Load Balancing in AI Fabric</a></label></li><li><input type=checkbox id=section-5f3e07f6cf7921e5291ff7894e06b19b class=toggle>
<label for=section-5f3e07f6cf7921e5291ff7894e06b19b class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/6-backend-network-topologies-for-ai-fabric/>Backend Network Topologies for AI Fabrics</a></label></li><li><input type=checkbox id=section-e19a1e9030cc104536fa46dd0bdb082c class=toggle>
<label for=section-e19a1e9030cc104536fa46dd0bdb082c class="flex justify-between"><a href=/tech-book/docs/ai-ml-dc/7-backend-network-in-gpu-fabric/>Backend Network/Rail Designs</a></label></li></ul></li><li><input type=checkbox id=section-3272b2d28b2b247027bf478619ca416f class=toggle>
<label for=section-3272b2d28b2b247027bf478619ca416f class="flex justify-between"><a href=/tech-book/docs/data-center/>Data Center Tips</a></label><ul><li><input type=checkbox id=section-984f932c7aba4f0a1841e8413165c947 class=toggle>
<label for=section-984f932c7aba4f0a1841e8413165c947 class="flex justify-between"><a href=/tech-book/docs/data-center/data-center-ethernet/>Data Center Ethernet</a></label></li><li><input type=checkbox id=section-bc5ac88940153a700e63e3be886c63cc class=toggle>
<label for=section-bc5ac88940153a700e63e3be886c63cc class="flex justify-between"><a href=/tech-book/docs/data-center/data-center-technologies/>Data Center Technologies</a></label></li><li><input type=checkbox id=section-86fde1ddf43700ef8191e11c59a82cf1 class=toggle>
<label for=section-86fde1ddf43700ef8191e11c59a82cf1 class="flex justify-between"><a href=/tech-book/docs/data-center/data-center-network-virtualization/>Network Virtualization in Cloud Data Centers</a></label></li></ul></li><li><input type=checkbox id=section-ddf784688e0c6d5abb681d2c57851559 class=toggle>
<label for=section-ddf784688e0c6d5abb681d2c57851559 class="flex justify-between"><a href=/tech-book/docs/manageability/>Manageability</a></label><ul><li><input type=checkbox id=section-33ac730897af6feca81c1fdb7869c57e class=toggle>
<label for=section-33ac730897af6feca81c1fdb7869c57e class="flex justify-between"><a href=/tech-book/docs/manageability/why-grpc-on-http2/>gRPC on HTTP/2</a></label></li></ul></li><li><input type=checkbox id=section-c14ae944424668ef125e10cd791a3d3d class=toggle>
<label for=section-c14ae944424668ef125e10cd791a3d3d class="flex justify-between"><a href=/tech-book/docs/networking-tips/>Networking Tips</a></label><ul><li><input type=checkbox id=section-78fdf21c03c55935d3146441b06faf3e class=toggle>
<label for=section-78fdf21c03c55935d3146441b06faf3e class="flex justify-between"><a href=/tech-book/docs/networking-tips/dns/>DNS Overview</a></label></li><li><input type=checkbox id=section-bbcb027a658dc7a2333d59078ee507f9 class=toggle>
<label for=section-bbcb027a658dc7a2333d59078ee507f9 class="flex justify-between"><a href=/tech-book/docs/networking-tips/ecmp/>ECMP Load Balancing</a></label></li><li><input type=checkbox id=section-3b39b86f18b3451e5b8a1b81c369549c class=toggle>
<label for=section-3b39b86f18b3451e5b8a1b81c369549c class="flex justify-between"><a href=/tech-book/docs/networking-tips/ip-fragmentation/>IP Fragmentation - IPv4 & IPv6</a></label></li><li><input type=checkbox id=section-c6d06c54cc91b0bc3f948d33b437fa8b class=toggle>
<label for=section-c6d06c54cc91b0bc3f948d33b437fa8b class="flex justify-between"><a href=/tech-book/docs/networking-tips/ip-tos-dscp/>IP Precedence And TOS | DSCP</a></label></li><li><input type=checkbox id=section-5f3260c76dd37177e3f89057bfe520ae class=toggle>
<label for=section-5f3260c76dd37177e3f89057bfe520ae class="flex justify-between"><a href=/tech-book/docs/networking-tips/traceroute/>Linux traceroute tool</a></label></li><li><input type=checkbox id=section-a26cc3fafb36cbc55527adf39ec83849 class=toggle>
<label for=section-a26cc3fafb36cbc55527adf39ec83849 class="flex justify-between"><a href=/tech-book/docs/networking-tips/mlag/>Multi Chassis Link Aggregation Basics</a></label></li><li><input type=checkbox id=section-36409a0abcb2d4d4baf2e0b682d1a5dd class=toggle>
<label for=section-36409a0abcb2d4d4baf2e0b682d1a5dd class="flex justify-between"><a href=/tech-book/docs/networking-tips/qos/>QoS</a></label></li><li><input type=checkbox id=section-db41e3547d316b01acf9a0ce9c04ef34 class=toggle>
<label for=section-db41e3547d316b01acf9a0ce9c04ef34 class="flex justify-between"><a href=/tech-book/docs/networking-tips/spine-leaf-arch/>Spine-leaf Architecture Basics</a></label></li><li><input type=checkbox id=section-0eb0d409074a76b8cb02624655e2434d class=toggle>
<label for=section-0eb0d409074a76b8cb02624655e2434d class="flex justify-between"><a href=/tech-book/docs/networking-tips/tcp-congestion/>TCP Congestion Control</a></label></li><li><input type=checkbox id=section-3d1710947b3c5be1a1cc33d88fcc6f54 class=toggle>
<label for=section-3d1710947b3c5be1a1cc33d88fcc6f54 class="flex justify-between"><a href=/tech-book/docs/networking-tips/tcp-data-transfer/>TCP Data Transfer</a></label></li></ul></li><li><input type=checkbox id=section-f0a392f2f083f28a4991336773716a63 class=toggle>
<label for=section-f0a392f2f083f28a4991336773716a63 class="flex justify-between"><a href=/tech-book/docs/optical-knowledge/>Optical Knowledge</a></label><ul><li><input type=checkbox id=section-18261b95a92d4fa86116243edca4e9fb class=toggle>
<label for=section-18261b95a92d4fa86116243edca4e9fb class="flex justify-between"><a href=/tech-book/docs/optical-knowledge/optical-breakout/>Optical Transceiver(Grey) & Breakout Model</a></label></li></ul></li><li><input type=checkbox id=section-a55840d746138b3d1fedb81acbccdded class=toggle>
<label for=section-a55840d746138b3d1fedb81acbccdded class="flex justify-between"><a href=/tech-book/docs/programming-tips/>Programming Tips</a></label><ul><li><input type=checkbox id=section-f929f1fe13cb5d6cc96ca3e98f9d9777 class=toggle>
<label for=section-f929f1fe13cb5d6cc96ca3e98f9d9777 class="flex justify-between"><a href=/tech-book/docs/programming-tips/c++/>C++ Tips</a></label></li></ul></li><li><input type=checkbox id=section-b35dbf5ebcd4c19926cf5a9aab6c7655 class=toggle checked>
<label for=section-b35dbf5ebcd4c19926cf5a9aab6c7655 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/>SystemDesign-Tips</a></label><ul><li><input type=checkbox id=section-4a618bc3b0b30107f0cec6d3bd6c025f class=toggle>
<label for=section-4a618bc3b0b30107f0cec6d3bd6c025f class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/code-deployment-system/>Design A Code-Deployment System</a></label></li><li><input type=checkbox id=section-e600754306aa95ce9c5a72b5efec6d7a class=toggle>
<label for=section-e600754306aa95ce9c5a72b5efec6d7a class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/stock-broker/>Design A Stock-Broker System</a></label></li><li><input type=checkbox id=section-bfa7a29878f65cfbb179e491c1211fa8 class=toggle>
<label for=section-bfa7a29878f65cfbb179e491c1211fa8 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/design-amazon/>Design Amazon</a></label></li><li><input type=checkbox id=section-5456837e25872f6352d861a9b5662cb1 class=toggle checked>
<label for=section-5456837e25872f6352d861a9b5662cb1 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/design-slack/ class=active>Design Slack</a></label></li><li><input type=checkbox id=section-5a78d16f54536a400b654f17f917bce1 class=toggle>
<label for=section-5a78d16f54536a400b654f17f917bce1 class="flex justify-between"><a href=/tech-book/docs/systemdesign-tips/google-drive/>Google Drive - Design</a></label></li></ul></li></ul><ul><li><a href=/tech-book/posts/>Blog</a></li><li><a href=https://prasenjitmanna.com/ target=_blank rel=noopener>Prasenjit's Blog</a></li><li><a href=https://prasenjitmanna.com/tech-book/ target=_blank rel=noopener>Prasenjit - Tech Book</a></li><li><a href=https://prasenjitmanna.com/upskills/ target=_blank rel=noopener>Prasenjit - Upskills</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/tech-book/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Design Slack</strong>
<label for=toc-control><img src=/tech-book/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#1-gathering-system-requirements>1. Gathering System Requirements</a></li><li><a href=#2-coming-up-with-a-plan>2. Coming Up With A Plan</a></li><li><a href=#3-persistent-storage-solution--app-load>3. Persistent Storage Solution & App Load</a></li><li><a href=#4-load-balancing>4. Load Balancing</a></li><li><a href=#5-smart-sharding>5. &ldquo;Smart&rdquo; Sharding</a></li><li><a href=#6-pubsub-system-for-real-time-behavior>6. Pub/Sub System for Real-Time Behavior</a></li><li><a href=#7-system-diagram>7. System Diagram</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h3 id=1-gathering-system-requirements>1. Gathering System Requirements
<a class=anchor href=#1-gathering-system-requirements>#</a></h3><p>As with any systems design interview question, the first thing that we want to do is to gather system requirements; we need to figure out what system we&rsquo;re building exactly.</p><p>We&rsquo;re designing the core communication system behind Slack, which allows users to send instant messages in Slack channels.</p><p>Specifically, we&rsquo;ll want to support:</p><ul><li>Loading the most recent messages in a Slack channel when a user clicks on the channel.</li><li>Immediately seeing which channels have unread messages for a particular user when that user loads Slack.</li><li>Immediately seeing which channels have unread mentions of a particular user, for that particular user, when that user loads Slack, and more specifically, the number of these unread mentions in each relevant channel.</li><li>Sending and receiving Slack messages instantly, in real time.</li><li>Cross-device synchronization: if a user has both the Slack desktop app and the Slack mobile app open, with an unread channel in both, and if they read this channel on one device, the second device should immediately be updated and no longer display the channel as unread.</li></ul><p>The system should have low latencies and high availability, catering to a single region of roughly 20 million users. The largest Slack organizations will have as many as 50,000 users, with channels of the same size within them.</p><p>That being said, for the purpose of this design, we should primarily focus on latency and core functionality; availability and regionality can be disregarded, within reason.</p><h3 id=2-coming-up-with-a-plan>2. Coming Up With A Plan
<a class=anchor href=#2-coming-up-with-a-plan>#</a></h3><p>We&rsquo;ll tackle this system by dividing it into two main sections:</p><ul><li>Handling what happens when a Slack app loads.</li><li>Handling real-time messaging as well as cross-device synchronization.</li></ul><p>We can further divide the first section as follows:</p><ul><li>Seeing all of the channels that a user is a part of.</li><li>Seeing messages in a particular channel.</li><li>Seeing which channels have unread messages.</li><li>Seeing which channels have unread mentions and how many they have.</li></ul><h3 id=3-persistent-storage-solution--app-load>3. Persistent Storage Solution & App Load
<a class=anchor href=#3-persistent-storage-solution--app-load>#</a></h3><p>While a large component of our design involves real-time communication, another large part of it involves retrieving data (channels, messages, etc.) at any given time when the Slack app loads. To support this, we&rsquo;ll need a persistent storage solution.</p><p>Specifically, we&rsquo;ll opt for a SQL database since we can expect this data to be structured and to be queried frequently.</p><p>We can start with a simple table that&rsquo;ll store every Slack channel.</p><p><strong>Channels</strong></p><table><thead><tr><th style=text-align:left>id (channelId): <em>uuid</em></th><th style=text-align:left>orgId: <em>uuid</em></th><th style=text-align:left>name: <em>string</em></th><th style=text-align:left>description: <em>string</em></th></tr></thead><tbody><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr></tbody></table><p>Then, we can have another simple table representing channel-member pairs: each row in this table will correspond to a particular user who is in a particular channel. We&rsquo;ll use this table, along with the one above, to fetch a user&rsquo;s relevant when the app loads.</p><p><strong>Channel Members</strong></p><table><thead><tr><th style=text-align:left>id: <em>uuid</em></th><th style=text-align:left>orgId: <em>uuid</em></th><th style=text-align:left>channelId: <em>uuid</em></th><th style=text-align:left>userId: <em>uuid</em></th></tr></thead><tbody><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr></tbody></table><p>We&rsquo;ll naturally need a table to store all historical messages sent on Slack. This will be our largest table, and it&rsquo;ll be queried every time a user fetches messages in a particular channel. The API endpoint that&rsquo;ll interact with this table will return a paginated response, since we&rsquo;ll typically only want the 50 or 100 most recent messages per channel.</p><p>Also, this table will only be queried when a user clicks on a channel; we don&rsquo;t want to fetch messages for all of a user&rsquo;s channels on app load, since users will likely never look at most of their channels.</p><p><strong>Historical Messages</strong></p><table><thead><tr><th style=text-align:left>id: <em>uuid</em></th><th style=text-align:left>orgId: <em>uuid</em></th><th style=text-align:left>channelId: <em>uuid</em></th><th style=text-align:left>senderId: <em>uuid</em></th><th style=text-align:left>sentAt: <em>timestamp</em></th><th style=text-align:left>body: <em>string</em></th><th style=text-align:left>mentions: <em>List<uuid></em></th></tr></thead><tbody><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr></tbody></table><p>In order not to fetch recent messages for every channel on app load, all the while supporting the feature of showing which channels have unread messages, we&rsquo;ll need to store two extra tables: one for the latest activity in each channel (this table will be updated whenever a user sends a message in a channel), and one for the last time a particular user has read a channel (this table will be updated whenever a user opens a channel).</p><p><strong>Latest Channel Timestamps</strong></p><table><thead><tr><th style=text-align:left>id: <em>uuid</em></th><th style=text-align:left>orgId: <em>uuid</em></th><th style=text-align:left>channelId: <em>uuid</em></th><th style=text-align:left>lastActive: <em>timestamp</em></th></tr></thead><tbody><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr></tbody></table><p><strong>Channel Read Receipts</strong></p><table><thead><tr><th style=text-align:left>id: <em>uuid</em></th><th style=text-align:left>orgId: <em>uuid</em></th><th style=text-align:left>channelId: <em>uuid</em></th><th style=text-align:left>userId: <em>uuid</em></th><th style=text-align:left>lastSeen: <em>timestamp</em></th></tr></thead><tbody><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr></tbody></table><p>For the number of unread user mentions that we want to display next to channel names, we&rsquo;ll have another table similar to the read-receipts one, except this one will have a count of unread user mentions instead of a timestamp. This count will be updated (incremented) whenever a user tags another user in a channel message, and it&rsquo;ll also be updated (reset to 0) whenever a user opens a channel with unread mentions of themself.</p><p><strong>Unread Channel-User-Mention Counts</strong></p><table><thead><tr><th style=text-align:left>id: <em>uuid</em></th><th style=text-align:left>orgId: <em>uuid</em></th><th style=text-align:left>channelId: <em>uuid</em></th><th style=text-align:left>userId: <em>uuid</em></th><th style=text-align:left>count: <em>int</em></th></tr></thead><tbody><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr></tbody></table><h3 id=4-load-balancing>4. Load Balancing
<a class=anchor href=#4-load-balancing>#</a></h3><p>For all of the API calls that clients will issue on app load, including writes to our database (when sending a message or marking a channel as read), we&rsquo;re going to want to load balance.</p><p>We can have a simple round-robin load balancer, forwarding requests to a set of server clusters that will then handle passing requests to our database.</p><h3 id=5-smart-sharding>5. &ldquo;Smart&rdquo; Sharding
<a class=anchor href=#5-smart-sharding>#</a></h3><p>Since our tables will be very large, especially the messages table, we&rsquo;ll need to have some sharding in place.</p><p>The natural approach is to shard based on organization size: we can have the biggest organizations (with the biggest channels) in their individual shards, and we can have smaller organizations grouped together in other shards.</p><p>An important point to note here is that, over time, organization sizes and Slack activity within organizations will change. Some organizations might double in size overnight, others might experience seemingly random surges of activity, etc.. This means that, despite our relatively sound sharding strategy, we might still run into hot spots, which is very bad considering the fact that we care about latency so much.</p><p>To handle this, we can add a &ldquo;smart&rdquo; sharding solution: a subsystem of our system that&rsquo;ll asynchronously measure organization activity and &ldquo;rebalance&rdquo; shards accordingly. This service can be a strongly consistent key-value store like Etcd or ZooKeeper, mapping orgIds to shards. Our API servers will communicate with this service to know which shard to route requests to.</p><h3 id=6-pubsub-system-for-real-time-behavior>6. Pub/Sub System for Real-Time Behavior
<a class=anchor href=#6-pubsub-system-for-real-time-behavior>#</a></h3><p>There are two types of real-time behavior that we want to support:</p><ul><li>Sending and receiving messages in real time.</li><li>Cross-device synchronization (instantly marking a channel as read if you have Slack open on two devices and read the channel on one of them).</li></ul><p>For both of these functionalities, we can rely on a Pub/Sub messaging system, which itself will rely on our previously described &ldquo;smart&rdquo; sharding strategy.</p><p>Every Slack organization or group of organizations will be assigned to a Kafka topic, and whenever a user sends a message in a channel or marks a channel as read, our previously mentioned API servers, which handle speaking to our database, will also send a Pub/Sub message to the appropriate Kafka topic.</p><p>The Pub/Sub messages will look like:</p><pre tabindex=0><code>{
  &#34;type&#34;: &#34;chat&#34;,
  &#34;orgId&#34;: &#34;AAA&#34;,
  &#34;channelId&#34;: &#34;BBB&#34;,
  &#34;userId&#34;: &#34;CCC&#34;,
  &#34;messageId&#34;: &#34;DDD&#34;,
  &#34;timestamp&#34;: &#34;2020-08-31T01:17:02&#34;,
  &#34;body&#34;: &#34;this is a message&#34;,
  &#34;mentions&#34;: [&#34;CCC&#34;, &#34;EEE&#34;]
},
{
  &#34;type&#34;: &#34;read-receipt&#34;,
  &#34;orgId&#34;: &#34;AAA&#34;,
  &#34;channelId&#34;: &#34;BBB&#34;,
  &#34;userId&#34;: &#34;CCC&#34;,
  &#34;timestamp&#34;: &#34;2020-08-31T01:17:02&#34;
}
</code></pre><p>We&rsquo;ll then have a different set of API servers who subscribe to the various Kakfa topics (probably one API server cluster per topic), and our clients (Slack users) will establish long-lived TCP connections with these API server clusters to receive Pub/Sub messages in real time.</p><p>We&rsquo;ll want a load balancer in between the clients and these API servers, which will also use the &ldquo;smart&rdquo; sharding strategy to match clients with the appropriate API servers, which will be listening to the appropriate Kafka topics.</p><p>When clients receive Pub/Sub messages, they&rsquo;ll handle them accordingly (mark a channel as unread, for example), and if the clients refresh their browser or their mobile app, they&rsquo;ll go through the entire &ldquo;on app load&rdquo; system that we described earlier.</p><p>Since each Pub/Sub message comes with a timestamp, and since reading a channel and sending Slack messages involve writing to our persistent storage, the Pub/Sub messages will effectively be idempotent operations.</p><h3 id=7-system-diagram>7. System Diagram
<a class=anchor href=#7-system-diagram>#</a></h3><p>Final Systems Architecture</p><p><img src=https://prasenjitmanna.com/tech-book/diagrams/slack-system-diagram.svg alt=img|320x271></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/prmanna/tech-book/commit/6e8ce302dcfbac50b2aca7f69cdf4a9a5412dc11 title='Last modified by Prasenjit Manna | May 8, 2025' target=_blank rel=noopener><img src=/tech-book/svg/calendar.svg class=book-icon alt>
<span>May 8, 2025</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#1-gathering-system-requirements>1. Gathering System Requirements</a></li><li><a href=#2-coming-up-with-a-plan>2. Coming Up With A Plan</a></li><li><a href=#3-persistent-storage-solution--app-load>3. Persistent Storage Solution & App Load</a></li><li><a href=#4-load-balancing>4. Load Balancing</a></li><li><a href=#5-smart-sharding>5. &ldquo;Smart&rdquo; Sharding</a></li><li><a href=#6-pubsub-system-for-real-time-behavior>6. Pub/Sub System for Real-Time Behavior</a></li><li><a href=#7-system-diagram>7. System Diagram</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>